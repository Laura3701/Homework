*map* 遍历*数组对象 goodsList*，参数写 *item*，代表的是*数组里的每一个对象*

为什么要遍历呢？因为我们需要的效果是渲染每一条商品信息，而*每一条 是需要通过遍历来渲染的*。

下面的步骤都是写在 `goodsList.map(function(item){})`花括号里面的，箭头函数的形式就是 `map(item=>{})`

花括号里面的内容：

1. **解构对象里的每一个属性**
`const { picture, name, count, price, spec, gift } = item`

2. 改变**商品描述**（灰字的部分）
用 `Object.value(解构出的属性名 spec)`来获取每一个对象里的属性 *spce* 对应的属性值，并且 `join('/')` 写成需要的格式，赋值给 text
`const text = Object.values(spec).join('/')`

3. **赠品模块**的文字修改

（1）之前解构出的赠品模块是 *gift*，然后写` gift.split(',')` 把 gift这个属性名对应的值 '50g茶叶,清洗球,宝马,奔驰' *转化为数组*，变成 [50g茶叶,清洗球,宝马,奔驰]

（2）map 遍历这个数组，参数是 *item*，也就是这个*数组里的每一个元素*，然后{}里面写 `<span class="tag">【赠品】${item}</span>` ，这个模板字符串的意思是每次遍历都输出一个 <span>，并且*把一个 item 写到 span 里面*

（3）map 遍历数组之后，生成的依然是数组，要转化为字符串，所以要 join('')

（4）给这个gift split 之后生成的数组遍历 加上一个判断条件：如果有 gift，则生成 span，没有gift，则生成空字符串

4. 计算每个商品后面的**小计**模块，方法是单价乘以数量，单价需要乘100，再在乘完数量以后，除以100。然后计算结果取2位小数

5. 最后写出 **遍历 goodsList 需要return的结果**，也就是**每遍历一次，需要写到 .list 里面的内容**，实际上也就是一条产品信息。每遍历一次，就生成一条。

6. 以上内容之后，花括号结束，然后把整个 goodsList.map 的内容通过 join('')转化为字符串，赋值给 .list 的 innerHTML，完成渲染